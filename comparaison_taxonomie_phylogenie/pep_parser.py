import os 
import csv 
from Bio import Phylo 
from decimal import *

from peptides import Peptides
from molmass import *
from peak_MS_parser import *

acides_amines = ['G','P','A','V','L','I','M','C','F','Y','W','H','K','R','Q','N','E','D','S','T']


def fasta_format_checker(file_name): 
    """Checks if the given file is a valid FASTA format

    Args:
        file_name (str): the name of the file with the proteic sequences used to build the phylogenetic tree in fasta format

    Returns:
        bool: whether or not the file is formatted correctly
    """
    #we check before hand if the file is formatted correctly
    valid_response = False
    try:
        with open(file_name, "r") as filin: #we read the file
            l = filin.readline() #we read the 1st line
            if l[0] == ">": #we check if the 1st character is ">" as required in a fasta format
                valid_response = True
                return valid_response
            else:
                print("Your file is not formatted correctly, please try another")
    except FileNotFoundError:
        print("Please verify the file's name")


def read_multi_fasta(file_name): 
    """Read a multifasta file and return a dictionary with the sequence and the name of the species.

    Args:
        file_name (str): the name of the file with the proteic sequences used to build the phylogenetic tree in fasta format

    Returns:
        dict: dictionnary mapping the name of the specie and its proteic sequence
    """
    if fasta_format_checker(file_name):
        seq_dict = {}
        with open(file_name, "r") as filin: #we read the file
            l = filin.readline() #we begin to read the 1st line
            while l != "":
                ligne_entete = l.rstrip() 
                name = ligne_entete[1:] #we define the 1st line as the name of the 1st sequence without the ">"
                seq = ""
                s = filin.readline() #we begin to read the 2nd line
                while s != "" and s[0] != ">": 
                    seq += s.rstrip() #we add the line to the sequence
                    s = filin.readline()
                if name not in seq_dict:
                    seq_dict[name] = [seq]
                else:
                    seq_dict[name].append(seq)
                l = s

    return seq_dict


def newick_to_xml_with_seq(seq_dict, tree_taxo, output_dir):
    """This function converts a Tree in Newick to a phyloXML tree and links the proteic sequence to the clade in the tree.

    Args:
        seq_dict (dict): dictionnary mapping the name of the specie and its proteic sequence
        tree_taxo (Tree): the Tree object build from the taxonomic tree in Newick format

    Raises:
        Exception: if a specie in the tree doesn't have a proteic sequence linked with it

    Returns:
        tuple: (Tree object in phyloxml, path to the phyloxml file)
    """
    tree_taxo_xml = tree_taxo.as_phyloxml() #converti l'object Tree fait en Newick en phyloxml
    for clade in tree_taxo_xml.get_terminals(): #on prend toutes les espèces (les feuilles de l'arbre)
        key = clade.name
        if key in seq_dict: #si une espèce dans l'arbre se retrouve dans le dictionnaire (et donc a une séquence protéique)
            for seq in seq_dict[key]:
                mol_seq = Phylo.PhyloXML.MolSeq(seq) #on crée un object MolSeq à partir de la séquence protéique
                sequence = Phylo.PhyloXML.Sequence(mol_seq=mol_seq) #on crée un object Sequence qui a pour attribut l'objet MolSeq
                clade.sequences.append(sequence) #on ajoute l'object Sequence dans l'objet Clade de l'arbre phyloxml
        else:
            raise Exception("The species {} don't have a sequence".format(clade.name)) #prévient si une espèce de l'arbre n'a pas de séquence protéique associée
    #On sauvergarde l'arbre phyloxml dans un fichier
    name = os.path.join(output_dir, "taxonomy.xml")
    Phylo.write(tree_taxo_xml, name, "phyloxml")

    return tree_taxo_xml, name


def pep_parser_rpg(csv_file, threshold): 
    """Parse the file generated by rpg and returns a list of peptide objects

    Args:
        csv_file (str): the name of the csv file
        threshold (str): the resolution (.3f ou .1f)

    Raises:
        NameError: if the input is not a csv file

    Returns:
        list: the list of peptides obj from the rpg file
    """
    _, ext = os.path.splitext(csv_file)
    if ext != ".csv":
        raise NameError("the input file must be a csv file")
    list_pep = []
    f= open (csv_file)
    myReader = csv.reader(f)
    next(myReader)
    for row in myReader:
        tmp = True
        seq = row[7]
        for elt in seq:
            if elt not in acides_amines:
                tmp = False
        if tmp :
            f = Formula('peptide({})'.format(seq))
            mass = [format(f.isotope.mass, threshold)]
            node = []
            if list_pep != []:
                list_pep_seq = [pep.get_seq() for pep in list_pep]
                if seq not in list_pep_seq:
                    list_pep.append(Peptides(seq, mass, node))
            else:
                list_pep.append(Peptides(seq, mass, node))
    return list_pep


def which_species_pep_present(list_pep, tree_taxo_xml):
    """Search peptides in list_pep in the sequences linked with the nodes in the taxonomy

    Args:
        list_pep (list): list of peptides obj from rpg
        tree_taxo_xml (str): the path to the taxonomy file in phyloXML

    Returns:
        list: list of peptide obj but the attributes nodes updated with the species they appear in.
    """
    dict_pep = {}
    tree_taxo_phyloxml = Phylo.read(tree_taxo_xml, 'phyloxml')

    for pep in list_pep:
        pep_seq = pep.get_seq()
        liste_species = []
        for clade in tree_taxo_phyloxml.get_terminals():
            for seq in clade.sequences:
                current_seq = str(seq.mol_seq)
                if pep_seq in current_seq:
                    liste_species.append(clade)
        if liste_species == []:
            print("This pep is not present in any of the sequences : {}".format(pep_seq))
        if pep not in dict_pep:
            dict_pep[pep] = liste_species
        else:
            print("This peptide already exists :{}".format(pep_seq))
    
    for pep, species in dict_pep.items():
        pep.set_nodes(species)
            
    return list(dict_pep.keys())


def get_leaf_nodes(node):
    """Get all leaf nodes of a node (clade).

    Args:
        node (Clade): the clade (subtree) we want to have all the leaves from

    Returns:
        list: list containing all the leaves of the clade (subtree)
    """
    leaves = []
    collect_leaf_nodes(node,leaves)
    return leaves #la liste avec toutes les feuilles du sous arbre

def collect_leaf_nodes(clade, leaves): 
    """Collect all the leaves from a clade recursively

    Args:
        clade (Clade): the clade we want to collect the leaves from
        leaves (list): the list containing all the leaves collected from the clade
    """
    if clade is not None:
        if len(clade.clades) == 0:
            leaves.append(clade) #on ajoute l'object clade dans la liste si c'est une feuille
        for n in clade.clades:
            collect_leaf_nodes(n, leaves) #on continue dans les sous arbre fils recursivement


def terminal_child_node_duplicate_remover(mrca):
    """Remove duplicate species sometimes found in the list generated by ".clades" attribute

    Args:
        mrca (Clade): The clade corresponding to the mrca

    Returns:
        list: the childs of the mrca but without duplicate leaves (species)
    """
    liste_child = []
    for node in mrca.clades: #pour tous les fils trouvés dans l'attribut ".clades"
        if not node.is_terminal(): #si c'est un noeud
            liste_child += get_leaf_nodes(node) #on ajoute toutes les feuilles de ce sous arbre
    for node in [x for x in mrca.clades if x.is_terminal()]: #pour tous les fils qui sont des feuilles
        if node in liste_child: #s'il est déjà présent dans la liste des fils
            mrca.clades.remove(node)  #on l'enlève
    return mrca.clades


def get_smallest_child_tree(mrca, pep, the_good_subtree):
    """Function to climb the taxonomic tree when possible so that the peptides may be associated with first correct nodes containing all the species the peptide appears in

    Args:
        mrca (Clade): The clade corresponding to the mrca
        pep (Peptide): The peptide we're looking at 
        the_good_subtree (list): The list that will countain the correct LCA for the species associated with the peptide (after climbing the taxonomy)
    
    Returns
        list: the_good_subtree updated with the correct LCA after climbing the taxonomy
    """
    def is_one_leaf_not_ok(pep, childs):
        """Returns weither or not a leaf in the list childs doesn't contain a specie where the peptide appears in

        Args:
            pep (Peptide): the peptide we're looking at
            childs (list): the list containing all the leaves contained after the LCA 
        
        Returns:
            bool: weither or not a leaf in the list childs doesn't contain a specie where the peptide appears in
        """
        list_species = [clade.name for clade in pep.get_nodes()] #la liste des espèces dans lesquelles le peptide apparait
        if any(leaf.name not in list_species for leaf in childs): 
            return True #si au moins une espèce dans le LCA n'est pas incluse dans la liste des espèces dans lesquelles le peptide apparait
        else:
            return False #le LCA contient toutes les espèces dans lesquelles le peptide apparait

    childs = get_leaf_nodes(mrca) #on trouve les feuilles de ce sous arbres
    if mrca != None:
        if childs != []:
            if is_one_leaf_not_ok(pep, childs): #si au moins une espèce du sous arbre du LCA n'est pas retrouvée dans la taxonomie
                liste_child_mrca = terminal_child_node_duplicate_remover(mrca) #on regarde les sous arbres fils
                if liste_child_mrca != []:
                    for n in liste_child_mrca:
                        get_smallest_child_tree(n, pep, the_good_subtree) #on revérifie la même condition récursivement sous les sous arbres
                
            else: #si toutes les espèces sont cohérentes avec les espèces dans lesquelles le peptide apparait on peut l'ajouter dans une liste
                the_good_subtree.append(mrca) 
                return the_good_subtree


def get_smallest_good_tree(tree_phylo_xml, list_pep): #MRCA = LCA
    """Update the attribute "nodes" of the peptide in order to climb the taxonomic tree when it's possible

    Args:
        tree_phylo_xml (str): the path to the phyloxml taxonomy
        list_pep (list): the list of peptides obj

    Returns:
        list: the list of peptides like list_pep but with the attribute "nodes" updated to contain the LCA of the species they appear in (climbing the taxonomy when possible)
    """ 
    tree_taxo_phyloxml = Phylo.read(tree_phylo_xml, 'phyloxml') #on lit le fichier taxonomie phyloxml
    for pep in list_pep:
        mrca = tree_taxo_phyloxml.common_ancestor([clade.name for clade in pep.get_nodes()]) # pour chaque peptide on retrouve le LCA des espèces dans lesquelles il apparait
        the_good_subtree = []
        get_smallest_child_tree(mrca, pep, the_good_subtree) # on regarde pour ce peptide jusqu'à où dans la taxonomie on peut remonter
        pep.set_nodes(the_good_subtree) #on update l'attribut "nodes"
    return list_pep


def pretty_print_peptides_csv(liste, output_dir):
    """Generate one of the csv result file

    Args:
        liste (list): list of Peptide objects
        output_dir (str): output directory filepath

    """
    with open(os.path.join(output_dir, 'peptides.csv'), 'w', newline='') as results:
        writer = csv.writer(results)
        writer.writerow(["Peptide Sequence", "Mass", "Nodes"])
        for peptide in liste:
            node_liste = [clade.name for clade in peptide.get_nodes()]
            rowToInsert = [peptide.get_seq(), peptide.get_mass(), node_liste]
            writer.writerow(rowToInsert)


def pretty_print_unique_peptides_fasta(liste, output_dir): 
    """Generate one of the result file in fasta

    Args:
        liste (list): list of Peptide objects
        output_dir (str): output directory filepath
    """
    with open(os.path.join(output_dir, 'peptides.fasta'), 'w', newline='') as results_fh:
        for peptide in liste:
            node_liste = [clade.name for clade in peptide.get_nodes()]
            results_fh.write(">{}|{}\n".format(peptide.get_mass(),
                                                node_liste))
            results_fh.write(peptide.get_seq() + "\n")


def list_pep_compare_ptm(liste_peak, liste_pep):
    """Function to compare the mass of the peptides and the mass of the peaks of a spectra

    Args:
        liste_peak (list): list of Peaks object from the spectra
        liste_pep (list): list of Peptides obj

    Returns:
        tuple: ({Peak obj = [Peptides list with equal mass]}, [orphan Peak])
    """
    liste_peak.sort(key=lambda x: Decimal(x.get_mass())) # on trie la liste en fonction de la masse
    
    liste_mass_pep_to_sort = []
    liste_mass_pep = [pep.get_mass() for pep in liste_pep] #on récupère toutes les masses (avec les PTM) des peptides
    for mass in liste_mass_pep: # mass == liste de masses 
        for m in mass:
            if m not in liste_mass_pep_to_sort:
                liste_mass_pep_to_sort.append(m)

    liste_mass_pep_to_sort.sort(key=lambda x: Decimal(x)) #on trie la liste des masses

    dict_peak_found = {}
    peak_not_found = []
    current_j = 0
    for i in range(len(liste_peak)): #on parcours la liste des pics
        for j in range(current_j,len(liste_mass_pep_to_sort)): #on parcours la liste des masses des peptides
            if Decimal(liste_peak[i].get_mass()).compare(Decimal(liste_mass_pep_to_sort[j])) == 0: #si la masse d'un pic est égale à une masse d'un peptide 
                if liste_peak[i] not in dict_peak_found:
                    dict_peak_found[liste_peak[i]] = [liste_mass_pep_to_sort[j]] #on rajoute la masse du peptide dans le dictionnaire sous la forme: Peak = [mass_peptide]
                else:
                    dict_peak_found[liste_peak[i]].append(liste_mass_pep_to_sort[j])
            elif Decimal(liste_peak[i].get_mass()).compare(Decimal(liste_mass_pep_to_sort[j])) == -1: #si la masse du pic est supérieures à la masse du peptide 
                current_j = j # on reprend au même endroit où le pic d'avant s'est arrêté
                if liste_peak[i] not in dict_peak_found:
                    peak_not_found.append(liste_peak[i]) #on l'ajoute à la liste des pics sans peptides associés
                break # on ne va pas plus loin dans la liste des masses des peptides et on passe au pic suivant

    dict_peak_found_mass = {}
    for key, item in dict_peak_found.items(): #on parcours le dictionnaire des pics avec des masses similaires à certaines masses de peptides
        for mass in item:
            for pep in liste_pep: #on retrouve de quel peptide la masse provient
                for mass_pep in pep.get_mass():
                    if Decimal(mass).compare(Decimal(mass_pep)) == 0:
                        if pep not in dict_peak_found:
                            dict_peak_found_mass[key] = [pep] # on peut alors associer les pics aux peptides qui ont la même masse que celle qui a été trouvé dans l'étape d'avant
                        else:
                            dict_peak_found_mass[key].append(pep)


    return dict_peak_found_mass, peak_not_found


def PTM_csv_parser(ptm_file, pep_liste, threshold):
    """AI is creating summary for PTM_csv_parser

    Args:
        ptm_file (str): the path to the file generated by PTM_mass_simuator
        pep_liste (list): the list of peptides with the attributes "nodes" updated 
        threshold (str): the precision to parse the mass (.3f or .1f)

    Raises:
        NameError: if the file is not a csv

    Returns:
        list: [description]
    """
    _, ext = os.path.splitext(ptm_file)
    if ext != ".csv":
        raise NameError("the input file must be a csv file")
    f= open (ptm_file)
    myReader = csv.reader(f)
    next(myReader)
    for row in myReader:
        seq = row[1]
        mass = format(float(row[-1]), threshold) # on a un chiffre à 1 ou 3 chiffres après la virgule en fonction de la précision choisie pour les masse (ici PTM)
        peptide = [pep for pep in pep_liste if pep.get_seq()==seq] #tout les peptides qui ont une séquence égale à la séquence du peptide dans le fichier de PTM_mass_simuator (utiliser pour retrouver les peptides dans le fichier)
        if peptide != []:
            if mass not in peptide[0].get_mass():
                peptide[0].append_mass(mass) #quand on a retrouvé le peptide on peut update l'attribut "mass" et ajouter les masses des PTM 
        else:
            print("The sequence is not found in the list of peptide given by rpg : {}".format(seq))
        

    return pep_liste


def peak_to_clade(dict_peak_found, tree_taxo_xml_name, output_dir):
    """AI is creating summary for peak_to_clade

    Args:
        dict_peak_found (dict): dictionnary mapping the peak obj with the peptides that share the same mass
        tree_taxo_xml_name (str): the pass to the taxonomy phyloXML file
        output_dir (str): the results folder

    Returns:
        tuple: (the phyXML taxonomy modified, path to the file)
    """
    tree_taxo_phyloxml = Phylo.read(tree_taxo_xml_name, 'phyloxml')
    for peak, liste_pep in dict_peak_found.items():
        obj_to_add = Phylo.PhyloXML.Other(tag="peak", value=str(peak)) #on ajoute le pic en tant qu'object "Other" de bio python pour l'associer à un obj "Clade" de l'arbre
        for pep in liste_pep:
            for clade in pep.get_nodes():
                name = clade.name
                clade_in_tree = next(tree_taxo_phyloxml.find_clades(name)) #on retrouve le LCA du peptides dans l'arbre
                if clade_in_tree != None:
                    clade_in_tree.other.append(obj_to_add) #on associe le pic avec le clade

    name = os.path.join(output_dir, "taxonomy_with_peak.xml")
    Phylo.write(tree_taxo_phyloxml, name, "phyloxml")

    return tree_taxo_phyloxml, name



def get_leaf_nodes_with_peaks(node, tree_taxo_xml_peak):
    """

    Args:
        node (Clade): the node we're looking at and want the nodes after them until the leaves
        tree_taxo_xml_peak (Tree): the taxonomic tree with the peaks

    Returns:
        list: list containing the clades in between the node and the leaves
    """
    liste_clade_in_path = []
    for term_node in tree_taxo_xml_peak.get_terminals(): #pour les feuilles terminales de l'arbre
        path = tree_taxo_xml_peak.trace(node, term_node) #on regarde tout les clades entre le noeud et la feuille
        for clade in path:
            if clade not in liste_clade_in_path:
                liste_clade_in_path.append(clade)

    return liste_clade_in_path


def get_terminal_node_with_peak(tree_taxo_xml_peak, node, terminal_nodes):
    """Returns the nodes that don't have any clade associated with a peak after them

    Args:
        tree_taxo_xml_peak (Tree): the taxonomic tree with the peaks
        node (Clade): the node we're looking at
        terminal_nodes (list): the list that will contain the terminal nodes
    
    Returns:
        list: the list terminal_nodes updated
    """
    def is_node_not_with_peak(childs):
        """Check if a node in childs has a peak associated with it
        Args:
            childs (list): list of clades between the node and the leaves from "get_leaf_nodes_with_peaks"

        Returns:
            bool: weither or not there is a clade in childs with a peak associated with it
        """
        if any(child.other != [] for child in childs): #il y a un pic présent "en dessous" donc pas terminal
            return True
        else:
            return False


    childs = get_leaf_nodes_with_peaks(node, tree_taxo_xml_peak) #on trouve les clades entre le noeud et les feuilles terminales
    if node != None:
        if childs != []:
            if is_node_not_with_peak(childs): #si un noeud fils a un pic 
                liste_child = terminal_child_node_duplicate_remover(node) #on regarde les sous arbres fils
                if liste_child != []:
                    for n in liste_child:
                        get_terminal_node_with_peak(tree_taxo_xml_peak, n, terminal_nodes) #on revérifie la même condition récursivement sous les sous arbres
                
            else: #si c'est bien terminal et aucun noeud en dessous avec un pic 
                terminal_nodes.append(node) 
                return terminal_nodes
        if node.is_terminal(): #si on arrive à la feuille, elle sera forcément terminale car pas de noeud après 
            terminal_nodes.append(node) 
            return terminal_nodes


def terminal_node_with_peak(tree_taxo_xml_peak):  
    """Returns a list of terminal nodes in the tree

    Args:
        tree_taxo_xml_peak (Tree): the taxonomic tree with the peak associated with the clades

    Returns:
        list: list of terminal nodes
    """
    terminal_nodes = []
    node = tree_taxo_xml_peak.root # on commence par la racine de l'arbre
    get_terminal_node_with_peak(tree_taxo_xml_peak, node, terminal_nodes) # la fonction qui permet de trouver les noeuds terminaux sans noeud avec un pic en dessous

    return terminal_nodes


def nb_peak_between_root_and_clade(clade, tree_taxo_xml_peak):
    """AI is creating summary for nb_peak_between_root_and_clade

    Args:
        clade (Clade): the terminal clade we're looking at
        tree_taxo_xml_peak (Tree): the taxonomic tree phyloXML with peaks

    Returns:
        int: the number of peaks associated with a peptide between the root and the clade
    """
    counter_peak = 0
    path = tree_taxo_xml_peak.get_path(clade) #chemin de la racine jusqu'au clade
    path.insert(0, tree_taxo_xml_peak.root) #on rajoute la racine car par défaut n'apparait pas dans la liste retourné par get_path

    for node in path:
        if node.other != []: #si on retrouve un pic (dans l'attribut other du clade)
            counter_peak += len(node.other) #on ajoute le nombre de pic

    return counter_peak


def pretty_print_term_nodes_csv(terminal_nodes, output_dir, tree_taxo_xml_peak):
    """Permet le formatage du fichier txt seulement pour les peptides uniques pour chaque protéine

    Args:
        terminal_nodes (list): list of terminal nodes
        output_dir (str): the path results
        tree_taxo_xml_peak (Tree): the taxonomic tree with the peaks

    """
    with open(os.path.join(output_dir, 'terminal_nodes.csv'), 'w', newline='') as results:
        writer = csv.writer(results)
        writer.writerow(["Clade", "Level", "Nb of peptide linked with a peak between the root and the clade"])
        level = ""
        for clade in terminal_nodes:
            path = tree_taxo_xml_peak.get_path(clade)
            if len(clade.name.split("_")) >= 2:
                level = "specie" #si le nom du clade est composé de 2 parties c'est une espèces
            else:
                if clade.name.endswith("dae"): #si le nom fini en "dae" c'est une famille
                    level = "family"
                else:
                    for i in reversed(range(len(path))):
                        if clade.name == path[i].name: 
                            if path[i+1].name.split("_")[0] == clade.name: #si le nom du clade est le même que la première partie du nom du clade après lui alors c'est un nom de genre ex: Bos -> Bos_taurus
                                level = "genus"
                                break
                    if level != "genus":
                        level = "Ordre"
            
            nb_peak = nb_peak_between_root_and_clade(clade, tree_taxo_xml_peak) #fonction pour calculer les nombres de peak associés à un peptides entre la racine et le clade (à vérifier)
            
            rowToInsert = [clade.name, level, nb_peak]
            writer.writerow(rowToInsert)